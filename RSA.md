# RSA加密算法是一种非对称加密算法

对极大整数做因数分解的难度决定了RSA算法的可靠性。如果将来发现一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但目前来看找到这样的算法的可能性是非常小的。目前只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。

## 何为非对称加密?
就是会有一个密钥对，一个叫公钥，可以公布与众；另一个叫私钥，只能自己保管，决不可泄露。使用公钥加密的密文，可以使用私钥解密；使用私钥加密的密文可言使用公钥解密。


## RSA 对加密数据的大小有限制
最大不大于密钥长度。例如在使用 512 bit 的密钥时，最大可以加密 512/8= 64Bytes 的数据，也就是最长可以加密64位长度的字符串。这个秘钥长度是可以在生成密钥对时指定的，最早有128、256、 1024 、2048...这个秘钥长度可以随意指定8的整数倍，但是JDK8最低支持的长度是512了，可以使用第三方提供的依赖包支持更低位数。RSA秘钥长度越长，越安全，但是加解密越慢，但是没有想象的那么慢，只是相对对称加密慢。使用前可以进行简单的测试，512bit的秘钥在普通个人pc上可以达到每毫秒10余次的加解密。RSA 加密或签名后的结果是不可读的二进制，使用时经常会转为 BASE64 码再传输。



## RSA是如果和保证每次加密的结果都不同的？
RSA使用时有个关键点就是填充算法。填充算法，就是加密时在明文后面使用填充算法生成随机字符串进行加密，由于填充算法生成的随机字符串不同，也就相当于被加密字符串不同，故密文不同。当然你也可以选择使用0填充算法，在上面的例子中，你的明文就可以是64Bytes字符串了，但是每次加密结果都是一样的。如果选择常用的加密填充算法RSA/ECB/PKCS1Padding，这个会随机填充至少11Bytes的字符，如果你的明文小于53Bytes会填充更多字符，所以每次密文都是不重复的，并且密文长度是固定的，是64Bytes。

  
# 签名
在说RSA签名之前，有必要先提一下摘要算法.摘要算法是密码学算法中非常重要的一个分支，它通过对所有数据提取指纹信息以实现数据签名、数据完整性校验等功能。无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同；但相同的输入必会产生相同的输出。它是不可逆的，所以不能被解密。目前比较常用有MD5和SHA系列。MD5以512bit分组来处理输入的信息，且每一分组又被划分为16个32bit子分组，经过了一系列的处理后，算法的输出由四个32bit分组组成，将这四个32bit分组级联后将生成一个128bit散列值，即128/8=16Bytes。一般生成的16Bytes是机器可读，但是人不可读，会使用Base64编码为24Bytes人可读的字符串。Base64最终会编码为使用【A-Za-z0-9+/】等64个字符表示，有时候需要使用=在末尾填充。有兴趣可以了解下Base64编码原理。
我们以MD5withRSA签名算法为例，即使用MD5摘要，用RSA签名。首先将数据使用MD5进行摘要，生成一个16Bytes数据，RSA再对这些数据编码后进行加密。验证签名的过程是先解密获取到摘要值，再对原文进行摘要进行比较，一致则说明验签成功，消息没有被篡改。



# 重点来了，RSA加解密和签名有什么区别？

RSA加密由于长度限制只能加密比较小的敏感数据，所以只有少量的关键数据需要传送，可以使用RSA加解密的方式，如果实在有比较长的敏感数据需要传送，需要把明文拆分后分段加密，对方解密后再拼接；

也正式由于RSA对明文长度的限制及明文长度过长以后的性能问题，签名算法得到了应用。签名对明文长度无限制，因为得到的摘要长度是固定的，RSA只需要对摘要加密后，与明文一起发送给对方，对方可以验证数据是否被篡改。

综上，加密只能应用在少量的敏感数据传送，而签名对长度无限制；加密明文不可见，签名明文可见，所以只能保证不被篡改，并不能保证不被人看到。签名通常是用于防止抵赖，即如果验证你的签名通过，就认为这是你发送过来的数据。