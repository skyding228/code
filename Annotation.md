# 注解详细说明

## Processor
rt.jar 中注解处理器接口

注解处理按照一定的顺序执行多轮次。每一轮，处理器可能会处理在源文件中发现的注解及上一轮产生的注解的子集。
第一轮处理虚拟机运行时的初始化输入，这些初始化输入是虚拟的第0轮的处理结果。如果一个处理器会执行某一轮，那么将会执行接下来的所有轮，包括最后一轮，
即使没有需要它处理的注解。这些处理器有可能会处理虚拟机操作产生的隐式文件。

每个实现此接口的处理器必须提供一个public的无参构造方法。基础设施会调用这个方法进行实例化，并按照如下方式进行交互：

1. 如果发现一个处理器对象没有被使用，基础设施会调用无参构造方法进行实例化一个。
2. 接着，会调用init方法，参数是一个合适的ProcessingEnvironment.
3. 然后，会调用 getSupportedAnnotationTypes, getSupportedOptions, 和 getSupportedSourceVersion方法，这些方法只会调用一次，而不是每一轮都调用。
4. 基础设施会在合适的时候调用此对象的process方法，并不会为每一轮都创建一个对象。

如果不按照上述规范定义和使用处理器，那么处理器的行为是不可预期的。

工具使用discovery process 去查找处理器并决定是否需要运行。通过配置，这些潜在的处理器是可控的。 例如，对于一个JavaCompiler的候选处理器列表，
可以配置成直接或者使用spi查找的方式运行。其他的jvm实现可能有不同的配置机制，像命令行参数，更详细的可以查看具体的文档。
哪一个处理器会执行，是根据出现在根元素上的注解类型，它是否支持，是否处理来决定的。处理器可能会处理它所支持的注解类型的一个子集甚至空集。针对给定的轮次，
工具会计算出现在根元素上的注解类型。如果有至少一个此处理器支持的注解出现，那么这个注解就会从不匹配的注解类型集合中移除。当这个集合为空或者没有更多的处理器
时，本轮结束。如果没有发现注解，注解处理器依然会执行，只不过只有支持所有注解类型("*") 会执行。

如果有至少一个注解出现在此轮的根元素上，那么就认为发现了此类型的注解。针对这种说法，一个类型(属性/方法上)注解认为是出现在普通元素上，而不是根元素，
所以会不认为发现了在类上使用的此元素。


一个注解可以通过直接发现或者通过继承发现，但是如果包装在另一个注解里面是发现不了的。包含在注解里的注解，结果等同于调用Elements.getAllAnnotationMirrors(Element)才能发现。
由于包含在内部的注解认为未发现，为了正确处理可重复的注解类型，处理器建议包含支持可重复的注解和原本注解。

注意 ,如果一个处理器支持"*"类型，即表明支持所有的类型。所有，那就是个统一的处理器。例如，实现额外的合法性校验应该返回false，来防止其他的校验无法执行。

如果一个处理器抛出未检查的异常，工具将停止其他注解的处理。如果抛出错误，当前轮次将结束，后续的轮次也会感知到错误被抛出了。因为注解处理器运行在一个合作的环境中，
处理器应该只在不能恢复的时候才抛出错误。

在多线程环境下，支持每一轮或者跨轮次获取环境资源是，工具环境不是必须的。

如果一个获取处理器配置信息的方法返回null，返回无效的输入，或者抛出异常，这个基础建设会认为处于错误条件。

为了健壮性考虑，运行在不同的工具实现环境下，一个处理器应该具备以下属性：
1. 处理给定的输入的结果与其他输入是否存在无关。
2. 相同的输入一共得到相同的输出。
3. 处理A/B得到的结果应该给处理B/A得到的结果一致
4. 处理给定输入不依赖其他处理器的结果

直接基础AbstractProcessor 更方便。
